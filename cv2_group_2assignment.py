# -*- coding: utf-8 -*-
"""CV2_Group_2Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dhpqbsgOqDWHHrSXDsQppwDeftHaXVyk
"""
# import streamlit as st
# import cv2
# import numpy as np

# def main():
#     # Load an image
#     image = cv2.imread('image5.jpeg')

#     if image is not None and len(image.shape) >= 2:
#         height, width = image.shape[:2]
#     else:
#         # Handle the case where the image is None or doesn't have the expected shape
#         st.error("Failed to load the image or unexpected image shape.")
#         return

#         # Define the transformation matrix for different affine transformations
#         # 1. Translation
#         translation_matrix = np.float32([[1, 0, 50], [0, 1, 30]])  # Translate 50 pixels right and 30 pixels down
        
#         # 2. Rotation
#         rotation_matrix = cv2.getRotationMatrix2D((width / 2, height / 2), 45, 1)  # Rotate by 45 degrees
        
#         # 3. Scaling
#         scaling_matrix = np.float32([[0.5, 0, 0], [0, 2, 0]])  # Scale by 50% horizontally and 200% vertically
        
#         # 4. Shearing
#         shearing_matrix = np.float32([[1, 0.2, 0], [0.2, 1, 0]])  # Shear horizontally by 20% and vertically by 20%
        
#         # Apply the affine transformations
#         translated_image = cv2.warpAffine(image, translation_matrix, (width, height))
#         rotated_image = cv2.warpAffine(image, rotation_matrix, (width, height))
#         scaled_image = cv2.warpAffine(image, scaling_matrix, (width, height))
#         sheared_image = cv2.warpAffine(image, shearing_matrix, (width, height))
        
#         # Display the transformed images
#         print('Original Image')
#         cv2_imshow(image)
#         print('Translated Image')
#         cv2_imshow( translated_image)
#         print('Rotated Image')
#         cv2_imshow( rotated_image)
#         print('Scaled Image')
#         cv2_imshow( scaled_image)
#         print('Sheared Image')
#         cv2_imshow( sheared_image)
        
#         cv2.waitKey(0)
#         cv2.destroyAllWindows()
        
#         image = cv2.imread('image5.jpeg', 0)  # Load a grayscale image
#         enhanced_image = cv2.equalizeHist(image)
#         print('Contrast Enhancement (Histogram Equalization)')
#         cv2_imshow(enhanced_image)
        
#         image = cv2.imread('image5.jpeg')
#         alpha = 1.5  # Contrast control (1.0 means no change)
#         beta = 30    # Brightness control (0 means no change)
#         enhanced_image = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)
#         print('Brightness and Contrast Adjustment')
#         cv2_imshow(enhanced_image)
        
#         image = cv2.imread('image5.jpeg')
#         blurred_image = cv2.GaussianBlur(image, (5, 5), 0)
#         print('Smoothing and Blurring (Gaussian Blur)')
#         cv2_imshow(blurred_image)
        
#         import numpy as np
        
#         image = cv2.imread('image5.jpeg')
#         kernel = np.array([[-1, -1, -1],
#                            [-1, 9, -1],
#                            [-1, -1, -1]])
#         sharpened_image = cv2.filter2D(image, -1, kernel)
#         print('Sharpening (Unsharp Masking)')
#         cv2_imshow(sharpened_image)
        
#         image = cv2.imread('image5.jpeg')
#         corrected_image = cv2.xphoto.createSimpleWB()
#         corrected_image = corrected_image.balanceWhite(image)
#         print('Color Balance Adjustment')
#         cv2_imshow(corrected_image)

# if __name__ == '__main__':
#     main()

import streamlit as st
import cv2
import numpy as np

def main():
    # Load an image
    image = cv2.imread('image5.jpeg')

    if image is not None and len(image.shape) >= 2:
        height, width = image.shape[:2]
    else:
        # Handle the case where the image is None or doesn't have the expected shape
        st.error("Failed to load the image or unexpected image shape.")
        return

    # Define the transformation matrix for different affine transformations
    # 1. Translation
    translation_matrix = np.float32([[1, 0, 50], [0, 1, 30]])  # Translate 50 pixels right and 30 pixels down

    # 2. Rotation
    rotation_matrix = cv2.getRotationMatrix2D((width / 2, height / 2), 45, 1)  # Rotate by 45 degrees

    # 3. Scaling
    scaling_matrix = np.float32([[0.5, 0, 0], [0, 2, 0]])  # Scale by 50% horizontally and 200% vertically

    # 4. Shearing
    shearing_matrix = np.float32([[1, 0.2, 0], [0.2, 1, 0]])  # Shear horizontally by 20% and vertically by 20%

    # Apply the affine transformations
    translated_image = cv2.warpAffine(image, translation_matrix, (width, height))
    rotated_image = cv2.warpAffine(image, rotation_matrix, (width, height))
    scaled_image = cv2.warpAffine(image, scaling_matrix, (width, height))
    sheared_image = cv2.warpAffine(image, shearing_matrix, (width, height))

    # Display the transformed images
    st.image(image, caption='Original Image', use_column_width=True)
    st.image(translated_image, caption='Translated Image', use_column_width=True)
    st.image(rotated_image, caption='Rotated Image', use_column_width=True)
    st.image(scaled_image, caption='Scaled Image', use_column_width=True)
    st.image(sheared_image, caption='Sheared Image', use_column_width=True)

    # You can continue to display other images similarly.
    # Load a grayscale image
    image = cv2.imread('image5.jpeg', 0)
    if image is not None and len(image.shape) >= 2:
        enhanced_image = cv2.equalizeHist(image)
        st.image(enhanced_image, caption='Contrast Enhancement (Histogram Equalization)', use_column_width=True)

    # Load the original image again
    image = cv2.imread('image5.jpeg')

    alpha = 1.5  # Contrast control (1.0 means no change)
    beta = 30    # Brightness control (0 means no change)
    enhanced_image = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)
    st.image(enhanced_image, caption='Brightness and Contrast Adjustment', use_column_width=True)

    image = cv2.GaussianBlur(image, (5, 5), 0)
    st.image(image, caption='Smoothing and Blurring (Gaussian Blur)', use_column_width=True)

    import numpy as np

    kernel = np.array([[-1, -1, -1],
                       [-1, 9, -1],
                       [-1, -1, -1]])
    sharpened_image = cv2.filter2D(image, -1, kernel)
    st.image(sharpened_image, caption='Sharpening (Unsharp Masking)', use_column_width=True)

    corrected_image = cv2.xphoto.createSimpleWB()
    corrected_image = corrected_image.balanceWhite(image)
    st.image(corrected_image, caption='Color Balance Adjustment', use_column_width=True)

if __name__ == '__main__':
    main()
